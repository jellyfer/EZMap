/*
 * Pre-load necessary database. (Will be organized up as a class)
 * 
 */
        
#include "preload.h"

void street_ids_preload(unordered_map <string, vector<unsigned>> & street_ids_map){
   // unordered_map <string, vector<unsigned>> street_ids_map;
    string streetname;
    for (unsigned int x = 0; x < getNumberOfStreets(); x++)
    {
        streetname = getStreetName(x);
        if (street_ids_map.find(streetname) == street_ids_map.end()){
            vector<unsigned> id;
            id.push_back(x);
            street_ids_map.insert(make_pair(streetname, id));
        }
       
        else{
            street_ids_map[streetname].push_back(x);
        }
    }

  //  return street_ids_map;
    
}

void intersection_street_segments_preload(vector <vector<unsigned> > & id0_intersection_street_segments){
    unsigned i=0, intersectionNum=getNumberOfIntersections();
    
    vector<unsigned>streetsegmentlds;
    //std::vector<std::vector<unsigned> >id0_intersection_street_segments;
    
    //i=intersection id
    for(i=0; i< intersectionNum; i++){
        
        //The number of street segments at a intersection
        unsigned intersection_street_segs=getIntersectionStreetSegmentCount(i);
        
        for(unsigned j=0; j<intersection_street_segs; j++){
           
            //Store the specific street segment id in a vector
            StreetSegmentIndex streetSegmentldx;
            streetSegmentldx=getIntersectionStreetSegment(i,j);
            streetsegmentlds.push_back(streetSegmentldx);

        }
        //street segments indexed by the intersection id
        id0_intersection_street_segments.push_back(streetsegmentlds);
        streetsegmentlds.clear();
 
    }
  //  return id0_intersection_street_segments;

}


void street_street_segments_and_street_intersections_preload(unordered_map <StreetIndex, vector<unsigned>> & street_street_segments_map, unordered_map <StreetIndex, vector<unsigned>> & street_intersections_map) {
    StreetIndex street_id;
    unsigned to,from;
    for (unsigned int x = 0; x < getNumberOfStreetSegments(); x++)
    {
        street_id = getStreetSegmentInfo(x).streetID;
        to = getStreetSegmentInfo(x).to;
        from = getStreetSegmentInfo(x).from;
             
        //street_id does not exist in map
        if (street_street_segments_map.find(street_id) == street_street_segments_map.end()){
            vector<unsigned> segments;
            vector<unsigned> intersections;
            segments.push_back(x);
            intersections.push_back(to);
            if (to!=from)
                intersections.push_back(from);
            street_street_segments_map.insert(make_pair(street_id, segments));
            street_intersections_map.insert(make_pair(street_id, intersections));
        }
       //street_id exists in map
        else{
            street_street_segments_map[street_id].push_back(x);
            if (find(street_intersections_map[street_id].begin(), street_intersections_map[street_id].end(), from) == street_intersections_map[street_id].end())
                street_intersections_map[street_id].push_back(from);
            if (find(street_intersections_map[street_id].begin(), street_intersections_map[street_id].end(), to) == street_intersections_map[street_id].end())
                street_intersections_map[street_id].push_back(to);
        }
    }
    
    
    
}
void street_segment_length_preload(vector <double> & street_segment_length) {
   // vector <double> street_segment_length;
    //Pre-load the vector of curve points count.
    vector <unsigned> curve_point_count;
    curve_point_count_preload(curve_point_count);
    
    //Loop through all street segments and parse corresponding segment lengths into the vector.
    for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
        double length = 0.0;
        StreetSegmentInfo segment_info = getStreetSegmentInfo(i);
        IntersectionIndex from = segment_info.from;
        IntersectionIndex to = segment_info.to;
        unsigned int curvePointCount = curve_point_count[i];
         
        LatLon intersection_1 = getIntersectionPosition(from);
        LatLon intersection_2 = getIntersectionPosition(to);
         
        //Find length directly if there is no curve.
        if (curvePointCount == 0) {
            length = find_distance_between_two_points(intersection_1, intersection_2);
        } else {
            LatLon temp_1 = intersection_1;
        
            //Loop through all curved segments and add their lengths up.
            for (unsigned int x = 0; x < curvePointCount; x++) {
                LatLon temp_2 = getStreetSegmentCurvePoint(i, x);
                length += find_distance_between_two_points(temp_1, temp_2);
                temp_1 = temp_2;
            }
            //Add the last curved segment length between the last point and intersection_2.
            length += find_distance_between_two_points(temp_1, intersection_2);
        }
        street_segment_length.push_back(length);
    }
  //  return street_segment_length;
}

void street_length_preload(vector <double> & street_length) {
    //vector <double> street_length;

    //Loop through all street IDs and parse corresponding street lengths into the vector.
    for (unsigned int street_id = 0; street_id < getNumberOfStreets(); street_id++) {
        double length = 0.0;
        vector <unsigned> segment_id = find_street_street_segments(street_id);
        //Sum up the length of all segments on the given street.
        for (auto iter = segment_id.begin(); iter != segment_id.end(); iter++) {
            length += find_street_segment_length(*iter);
        }
        street_length.push_back(length);
    }
    //return street_length;
}

void speed_limit_preload(vector <double> & speed_limit) {
   // vector <double> speed_limit;
    
    //Parse all speed limits into a vector sorted by segment IDs.mp
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        speed_limit.push_back(getStreetSegmentInfo(segment_id).speedLimit);
    }
   // return speed_limit;
}

void curve_point_count_preload(vector <unsigned> & curve_point) {
    //vector <unsigned> curve_point;
    
    //Parse all numbers of curve points into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        curve_point.push_back(getStreetSegmentInfo(segment_id).curvePointCount);
    }
  //  return curve_point;
}
/*
void street_id_preload(vector <StreetIndex> & street_id) {
//    vector <unsigned> street_id;
    
    //Parse all index of street into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        street_id.push_back(getStreetSegmentInfo(segment_id).streetID);
    }
   // return street_id;
}

*/
