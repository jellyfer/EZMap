/*
 * Pre-load necessary database. (Will be organized up as a class)
 * 
 */
        
#include "preload.h"

void street_ids_preload(unordered_map <string, vector<unsigned>> & street_ids_map){
   // unordered_map <string, vector<unsigned>> street_ids_map;
    string streetname;
    for (unsigned int x = 0; x < getNumberOfStreets(); x++)
    {
        streetname = getStreetName(x);
        if (street_ids_map.find(streetname) == street_ids_map.end()){
            vector<unsigned> id;
            id.push_back(x);
            street_ids_map.insert(make_pair(streetname, id));
        }
       
        else{
            street_ids_map[streetname].push_back(x);
        }
    }

  //  return street_ids_map;
    
}

void street_street_segments_preload(unordered_map <StreetIndex, vector<unsigned>> & street_street_segments_map) {
  // vector <vector<unsigned>> street_street_segments;
    //Pre-load the vector of street IDs./*
    /*
    vector <StreetIndex> street_id_pre;
    street_id_preload(street_id_pre);
    
    //Loop through all street IDs and parse corresponding street segments vectors into the vector.
    for (unsigned int street_id = 0; street_id < getNumberOfStreets(); street_id++) {
        vector<unsigned> street_segments;
        
        //Loop through all street segments and parse corresponding street IDs into the vector.
        for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
            //Check if the street IDs match.
            if (street_id == street_id_pre[i])    
                street_segments.push_back(i);
        }
        street_street_segments.push_back(street_segments);
    }*/
  //  return street_street_segments;
    
    StreetIndex street_id;
    for (unsigned int x = 0; x < getNumberOfStreetSegments(); x++)
    {
        street_id = getStreetSegmentInfo(x).streetID;
        if (street_street_segments_map.find(street_id) == street_street_segments_map.end()){
            vector<unsigned> segments;
            segments.push_back(x);
            street_street_segments_map.insert(make_pair(street_id, segments));
        }
       
        else{
            street_street_segments_map[street_id].push_back(x);
        }
    }
    
    
    
}
void street_segment_length_preload(vector <double> & street_segment_length) {
   // vector <double> street_segment_length;
    //Pre-load the vector of curve points count.
    vector <unsigned> curve_point_count;
    curve_point_count_preload(curve_point_count);
    
    //Loop through all street segments and parse corresponding segment lengths into the vector.
    for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
        double length = 0.0;
        StreetSegmentInfo segment_info = getStreetSegmentInfo(i);
        IntersectionIndex from = segment_info.from;
        IntersectionIndex to = segment_info.to;
        unsigned int curvePointCount = curve_point_count[i];
         
        LatLon intersection_1 = getIntersectionPosition(from);
        LatLon intersection_2 = getIntersectionPosition(to);
         
        //Find length directly if there is no curve.
        if (curvePointCount == 0) {
            length = find_distance_between_two_points(intersection_1, intersection_2);
        } else {
            LatLon temp_1 = intersection_1;
        
            //Loop through all curved segments and add their lengths up.
            for (unsigned int x = 0; x < curvePointCount; x++) {
                LatLon temp_2 = getStreetSegmentCurvePoint(i, x);
                length += find_distance_between_two_points(temp_1, temp_2);
                temp_1 = temp_2;
            }
            //Add the last curved segment length between the last point and intersection_2.
            length += find_distance_between_two_points(temp_1, intersection_2);
        }
        street_segment_length.push_back(length);
    }
  //  return street_segment_length;
}

void street_length_preload(vector <double> & street_length) {
    //vector <double> street_length;

    //Loop through all street IDs and parse corresponding street lengths into the vector.
    for (unsigned int street_id = 0; street_id < getNumberOfStreets(); street_id++) {
        double length = 0.0;
        vector <unsigned> segment_id = find_street_street_segments(street_id);
        //Sum up the length of all segments on the given street.
        for (auto iter = segment_id.begin(); iter != segment_id.end(); iter++) {
            length += find_street_segment_length(*iter);
        }
        street_length.push_back(length);
    }
    //return street_length;
}

void speed_limit_preload(vector <double> & speed_limit) {
   // vector <double> speed_limit;
    
    //Parse all speed limits into a vector sorted by segment IDs.mp
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        speed_limit.push_back(getStreetSegmentInfo(segment_id).speedLimit);
    }
   // return speed_limit;
}

void curve_point_count_preload(vector <unsigned> & curve_point) {
    //vector <unsigned> curve_point;
    
    //Parse all numbers of curve points into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        curve_point.push_back(getStreetSegmentInfo(segment_id).curvePointCount);
    }
  //  return curve_point;
}
/*
void street_id_preload(vector <StreetIndex> & street_id) {
//    vector <unsigned> street_id;
    
    //Parse all index of street into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        street_id.push_back(getStreetSegmentInfo(segment_id).streetID);
    }
   // return street_id;
}

*/