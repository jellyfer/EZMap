/*
 * Pre-load necessary database. (Will be organized up as a class)
 * 
 */

#include "preload.h"
extern double cosLatAvgPOI;
extern double cosLatAvgCI;

void street_ids_preload(unordered_map <string, vector<unsigned>> &street_ids_map) {
    // unordered_map <string, vector<unsigned>> street_ids_map;
    string streetname;
    for (unsigned int x = 0; x < getNumberOfStreets(); x++) {
        streetname = getStreetName(x);
        if (street_ids_map.find(streetname) == street_ids_map.end()) {
            vector<unsigned> id;
            id.push_back(x);
            street_ids_map.insert(make_pair(streetname, id));
        } else {
            street_ids_map[streetname].push_back(x);
        }
    }

    //  return street_ids_map;

}

void intersection_street_segments_preload(vector <vector<unsigned> > & id0_intersection_street_segments) {
    unsigned i = 0, intersectionNum = getNumberOfIntersections();

    vector<unsigned>streetsegmentlds;
    //std::vector<std::vector<unsigned> >id0_intersection_street_segments;

    //i=intersection id
    for (i = 0; i < intersectionNum; i++) {

        //The number of street segments at a intersection
        unsigned intersection_street_segs = getIntersectionStreetSegmentCount(i);

        for (unsigned j = 0; j < intersection_street_segs; j++) {

            //Store the specific street segment id in a vector
            StreetSegmentIndex streetSegmentldx;
            streetSegmentldx = getIntersectionStreetSegment(i, j);
            streetsegmentlds.push_back(streetSegmentldx);

        }
        //street segments indexed by the intersection id
        id0_intersection_street_segments.push_back(streetsegmentlds);
        streetsegmentlds.clear();

    }
    //  return id0_intersection_street_segments;

}

void street_street_segments_preload(vector<vector<unsigned>> &street_street_segments) {
    street_street_segments.resize(getNumberOfStreets());
    for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
        street_street_segments[getStreetSegmentInfo(i).streetID].push_back(i);
    }
}

void street_intersections_preload(vector<vector<unsigned>> &street_intersections) {
    street_intersections.resize(getNumberOfStreets());
    StreetIndex street_id;
    unsigned to, from;
    for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
        street_id = getStreetSegmentInfo(i).streetID;
        to = getStreetSegmentInfo(i).to;
        from = getStreetSegmentInfo(i).from;
        //if from is not found
        if (find(street_intersections[street_id].begin(), street_intersections[street_id].end(), from) == street_intersections[street_id].end())
            street_intersections[street_id].push_back(from);
        //if to is not found
        if (find(street_intersections[street_id].begin(), street_intersections[street_id].end(), to) == street_intersections[street_id].end())
            street_intersections[street_id].push_back(to);
    }
}

/*
void street_street_segments_and_street_intersections_preload(unordered_map <StreetIndex, vector<unsigned>> & street_street_segments_map, unordered_map <StreetIndex, vector<unsigned>> & street_intersections_map) {
    StreetIndex street_id;
    unsigned to,from;
    for (unsigned int x = 0; x < getNumberOfStreetSegments(); x++)
    {
        street_id = getStreetSegmentInfo(x).streetID;
        to = getStreetSegmentInfo(x).to;
        from = getStreetSegmentInfo(x).from;
             
        //street_id does not exist in map
        if (street_street_segments_map.find(street_id) == street_street_segments_map.end()){
            vector<unsigned> segments;
            vector<unsigned> intersections;
            segments.push_back(x);
            intersections.push_back(to);
            if (to!=from)
                intersections.push_back(from);
            street_street_segments_map.insert(make_pair(street_id, segments));
            street_intersections_map.insert(make_pair(street_id, intersections));
        }
       //street_id exists in map
        else{
            street_street_segments_map[street_id].push_back(x);
            if (find(street_intersections_map[street_id].begin(), street_intersections_map[street_id].end(), from) == street_intersections_map[street_id].end())
                street_intersections_map[street_id].push_back(from);
            if (find(street_intersections_map[street_id].begin(), street_intersections_map[street_id].end(), to) == street_intersections_map[street_id].end())
                street_intersections_map[street_id].push_back(to);
        }
    }
    
    
    
}
void street_segment_length_preload(vector <double> & street_segment_length) {
   // vector <double> street_segment_length;
    //Pre-load the vector of curve points count.
    vector <unsigned> curve_point_count;
    curve_point_count_preload(curve_point_count);
    
    //Loop through all street segments and parse corresponding segment lengths into the vector.
    for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
        double length = 0.0;
        StreetSegmentInfo segment_info = getStreetSegmentInfo(i);
        IntersectionIndex from = segment_info.from;
        IntersectionIndex to = segment_info.to;
        unsigned int curvePointCount = curve_point_count[i];
         
        LatLon intersection_1 = getIntersectionPosition(from);
        LatLon intersection_2 = getIntersectionPosition(to);
         
        //Find length directly if there is no curve.
        if (curvePointCount == 0) {
            length = find_distance_between_two_points(intersection_1, intersection_2);
        } else {
            LatLon temp_1 = intersection_1;
        
            //Loop through all curved segments and add their lengths up.
            for (unsigned int x = 0; x < curvePointCount; x++) {
                LatLon temp_2 = getStreetSegmentCurvePoint(i, x);
                length += find_distance_between_two_points(temp_1, temp_2);
                temp_1 = temp_2;
            }
            //Add the last curved segment length between the last point and intersection_2.
            length += find_distance_between_two_points(temp_1, intersection_2);
        }
        street_segment_length.push_back(length);
    }
  //  return street_segment_length;
}
 */
void street_segment_length_preload(vector <double> & street_segment_length) {
    // vector <double> street_segment_length;
    //Pre-load the vector of curve points count.
    vector <unsigned> curve_point_count;
    curve_point_count_preload(curve_point_count);

    //Loop through all street segments and parse corresponding segment lengths into the vector.
    for (unsigned int i = 0; i < getNumberOfStreetSegments(); i++) {
        double length = 0.0;
        StreetSegmentInfo segment_info = getStreetSegmentInfo(i);
        IntersectionIndex from = segment_info.from;
        IntersectionIndex to = segment_info.to;
        unsigned int curvePointCount = curve_point_count[i];

        LatLon intersection_1 = getIntersectionPosition(from);
        LatLon intersection_2 = getIntersectionPosition(to);

        //Find length directly if there is no curve.
        if (curvePointCount == 0) {
            length = find_distance_between_two_points(intersection_1, intersection_2);
        } else {
            LatLon temp_1 = intersection_1;

            //Loop through all curved segments and add their lengths up.
            for (unsigned int x = 0; x < curvePointCount; x++) {
                LatLon temp_2 = getStreetSegmentCurvePoint(i, x);
                length += find_distance_between_two_points(temp_1, temp_2);
                temp_1 = temp_2;
            }
            //Add the last curved segment length between the last point and intersection_2.
            length += find_distance_between_two_points(temp_1, intersection_2);
        }
        street_segment_length.push_back(length);
    }
    //  return street_segment_length;
}

void street_length_preload(vector <double> & street_length) {
    //vector <double> street_length;

    //Loop through all street IDs and parse corresponding street lengths into the vector.
    for (unsigned int street_id = 0; street_id < getNumberOfStreets(); street_id++) {
        double length = 0.0;
        vector <unsigned> segment_id = find_street_street_segments(street_id);
        //Sum up the length of all segments on the given street.
        for (auto iter = segment_id.begin(); iter != segment_id.end(); iter++) {
            length += find_street_segment_length(*iter);
        }
        street_length.push_back(length);
    }
    //return street_length;
}

void speed_limit_preload(vector <double> & speed_limit) {
    // vector <double> speed_limit;

    //Parse all speed limits into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        speed_limit.push_back(getStreetSegmentInfo(segment_id).speedLimit);
    }
    // return speed_limit;
}

void curve_point_count_preload(vector <unsigned> & curve_point) {
    //vector <unsigned> curve_point;

    //Parse all numbers of curve points into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        curve_point.push_back(getStreetSegmentInfo(segment_id).curvePointCount);
    }
    //  return curve_point;
}
/*
void street_id_preload(vector <StreetIndex> & street_id) {
//    vector <unsigned> street_id;
    
    //Parse all index of street into a vector sorted by segment IDs.
    for (unsigned int segment_id = 0; segment_id < getNumberOfStreetSegments(); segment_id++) {
        street_id.push_back(getStreetSegmentInfo(segment_id).streetID);
    }
   // return street_id;
}

 */
//Quickly find relative distance. Only for the last two functions.

double quick_find_distance(LatLon point1, LatLon point2, double lat_avg) {

    //Convert into x,y coordinates.
    double x1 = point1.lon() * lat_avg;
    double x2 = point2.lon() * lat_avg;
    //Calculate the distance between two points with given function.
    double distance = (point2.lat() - point1.lat()) * (point2.lat() - point1.lat()) + (x2 - x1) * (x2 - x1);

    return distance;
}

//Quickly find the cos_lat_avg of all intersections.

double cos_lat_avg_CI() {
    double sum = 0;
    for (unsigned int i = 0; i < getNumberOfIntersections(); i++) {
        sum += getIntersectionPosition(i).lat();
    }
    double lat_avg = DEG_TO_RAD * sum / getNumberOfIntersections();
    //Taylor series
    double cosLatAvg = 1 - lat_avg * lat_avg / 2 + lat_avg * lat_avg * lat_avg * lat_avg / 4 - lat_avg * lat_avg * lat_avg * lat_avg * lat_avg * lat_avg / 6;

    return cosLatAvg;
}

//Quickly find the cos_lat_avg of all points of interest.

double cos_lat_avg_POI() {
    double sum = 0;
    for (unsigned int i = 0; i < getNumberOfPointsOfInterest(); i++) {
        sum += getPointOfInterestPosition(i).lat();
    }
    double lat_avg = DEG_TO_RAD * sum / getNumberOfPointsOfInterest();
    //Taylor series
    double cosLatAvg = 1 - lat_avg * lat_avg / 2 + lat_avg * lat_avg * lat_avg * lat_avg / 4 - lat_avg * lat_avg * lat_avg * lat_avg * lat_avg * lat_avg / 6;

    return cosLatAvg;
}

//Build a r-tree to store closest_point_of_interest.

bgi::rtree<value, bgi::rstar<10> > closest_point_of_interest_preload() {
    unsigned int size = getNumberOfPointsOfInterest();

    bgi::rtree<value, bgi::rstar<10> > rtree;
    for (unsigned i = 0; i < size; i++) {
        double x1 = getPointOfInterestPosition(i).lon() * cosLatAvgPOI;
        double y1 = getPointOfInterestPosition(i).lat();

        double x2 = getPointOfInterestPosition(i + 0.5f).lon() * cosLatAvgPOI;
        double y2 = getPointOfInterestPosition(i + 0.5f).lat();
        // create a box
        box b(point(x1, y1), point(x2, y2));
        // insert new value
        rtree.insert(make_pair(b, i));
    }

    return rtree;
}

//Build a r-tree to store closest_intersections.

bgi::rtree<value, bgi::rstar<10> > closest_intersection_preload() {
    unsigned int size = getNumberOfIntersections();

    bgi::rtree<value, bgi::rstar<10> > rtree;
    for (unsigned i = 0; i < size; i++) {
        double x1 = getIntersectionPosition(i).lon() * cosLatAvgCI;
        double y1 = getIntersectionPosition(i).lat();

        double x2 = getIntersectionPosition(i + 0.5f).lon() * cosLatAvgCI;
        double y2 = getIntersectionPosition(i + 0.5f).lat();
        // create a box
        box b(point(x1, y1), point(x2, y2));
        // insert new value
        rtree.insert(make_pair(b, i));
    }

    return rtree;
}
