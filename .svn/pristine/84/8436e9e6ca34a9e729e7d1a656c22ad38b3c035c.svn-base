#include <iostream>
#include <chrono>
#include <thread>
#include <cstdlib>
#include <vector>
#include <string>
#include "graphics.h"
#include "m2_M.h"

// Callbacks for event-driven window handling.
void drawscreen(void);
void act_on_new_button_func(void (*drawscreen_ptr) (void));
void act_on_button_press(float x, float y, t_event_buttonPressed event);
void act_on_mouse_move(float x, float y);
void act_on_key_press(char c, int keysym);

// A handy delay function for the animation example
void delay(long milliseconds);

// State variables for the example showing entering lines and rubber banding
// and the new button example.
// static bool line_entering_demo = false;
//static bool have_rubber_line = false;
static t_point rubber_pt; // Last point to which we rubber-banded.
static std::vector<t_point> line_pts; // Stores the points entered by user clicks.
static int num_new_button_clicks = 0;


// You can use any coordinate system you want.
// The coordinate system below matches what you have probably seen in math 
// (ie. with origin in bottom left).
// Note, that text orientation is not affected. Zero degrees will always be the normal, readable, orientation.
const t_bound_box initial_coords = t_bound_box(0, 0, 1100, 1150);


void delay(long milliseconds) {
    // if you would like to use this function in your
    // own code you will need to #include <chrono> and
    // <thread>
    std::chrono::milliseconds duration(milliseconds);
    std::this_thread::sleep_for(duration);
}


void act_on_new_button_func(void (*drawscreen_ptr) (void)) {
// Callback function for the new button we created. This function will be called
// when the user clicks on the button. It just counts how many
// times you have clicked the button.  

    char old_button_name[200], new_button_name[200];
    std::cout << "You pressed the new button!\n";
    setcolor(MAGENTA);
    setfontsize(12);
    drawtext(500, 500, "You pressed the new button!", 10000.0, FLT_MAX);
    sprintf(old_button_name, "%d Clicks", num_new_button_clicks);
    num_new_button_clicks++;
    sprintf(new_button_name, "%d Clicks", num_new_button_clicks);
    change_button_text(old_button_name, new_button_name);

    // Re-draw the screen (a few squares are changing colour with time)
    drawscreen_ptr();
}


/*void act_on_button_press(float x, float y, t_event_buttonPressed event) {
    t_point world;
    world.x = x;
    world.y = y;
    t_point screen = visibleWorldToVisibleScreen (world);
    
    
   // std::cout << "User clicked a mouse button at coordinates ("
            //<< screen.x << "," << screen.y << ")";
    
    
    
    * Called whenever event_loop gets a button press in the graphics *
     * area.  Allows the user to do whatever he/she wants with button *
     * clicks.                                                        */
/**//*

    std::cout << "User clicked a mouse button at coordinates ("
            << x << "," << y << ")";
    if (event.shift_pressed || event.ctrl_pressed) {
        std::cout << " with ";
        if (event.shift_pressed) {
            std::cout << "shift ";
            if (event.ctrl_pressed)
                std::cout << "and ";
        }
        if (event.ctrl_pressed)
            std::cout << "control ";
        std::cout << "pressed.";
    }
    std::cout << std::endl;

    if (line_entering_demo) {
        line_pts.push_back(t_point(x, y));
        have_rubber_line = false;

        // Redraw screen to show the new line.  Could do incrementally, but this is easier.
        drawscreen();
    }*/
//}*/

//void act_on_mouse_move(float x, float y) {
    // function to handle mouse move event, the current mouse position in the current world coordinate
    // system (as defined in your call to init_world) is returned
   
  //  std::cout << "Mouse move at " << x << "," <<  y << ")\n";
    /*
    if (line_pts.size() > 0) {
        // Rubber banding to a previously entered point.
        // Go into XOR mode.  Make sure we set the linestyle etc. for xor mode, since it is 
        // stored in different state than normal mode.
        set_draw_mode(DRAW_XOR);
        setlinestyle(SOLID);
        setcolor(WHITE);
        setlinewidth(1);
        int ipt = line_pts.size() - 1;

        if (have_rubber_line) {
            // Erase old line.  
            drawline(line_pts[ipt], rubber_pt);
        }
        have_rubber_line = true;
        rubber_pt.x = x;
        rubber_pt.y = y;
        drawline(line_pts[ipt], rubber_pt); // Draw new line
    }*/
//}

/*
#include <X11/keysym.h>

void act_on_key_press(char c, int keysym) {
    // function to handle keyboard press event, the ASCII character is returned
    // along with an extended code (keysym) on X11 to represent non-ASCII
    // characters like the arrow keys.

    std::cout << "Key press: char is " << c << std::endl;

#ifdef X11 // Extended keyboard codes only supported for X11 for now
    switch (keysym) {
        case XK_Left:
            std::cout << "Left Arrow" << std::endl;
            break;
        case XK_Right:
            std::cout << "Right Arrow" << std::endl;
            break;
        case XK_Up:
            std::cout << "Up Arrow" << std::endl;
            break;
        case XK_Down:
            std::cout << "Down Arrow" << std::endl;
            break;
        default:
            std::cout << "keysym (extended code) is " << keysym << std::endl;
            break;
    }
#endif
}

*/