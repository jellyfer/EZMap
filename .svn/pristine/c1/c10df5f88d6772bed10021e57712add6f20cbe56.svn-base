//if you want functions for get_visible_screen
//auto a = get_visible_screen().

//draw text function
//set to false if you want to draw from top left
//if you want to draw from middle, ignore it (or set to true)
//drawtext(get_visible_screen().right() - 40 - TEXTBOX_LENGTH + 10, 20 + 10, search_text, FLT_MAX, FLT_MAX, false);




//by saturday, have intersection to intersection input ready
//cout to the terminal the id to make sure its right



/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

#include "m1.h"
#include "m1_additional.h"
#include "m2_M.h"
#include <string>
#include <X11/Xlib.h>
#include <chrono>
#include "graphics.h"
#include "graphics.cpp"
#include <unordered_map>
#include <vector>
#include <boost/algorithm/string.hpp>
#include <algorithm>

using namespace std;
using namespace boost;

extern void act_on_new_button_func(void (*drawscreen_ptr) (void));
extern void act_on_button_press(float x, float y, t_event_buttonPressed event);
extern void act_on_mouse_move(float x, float y);
extern void act_on_key_press(char c, int keysym);
extern void drawscreen(void);
extern void delay(long milliseconds);
extern double cos_lat_avg_POI();
bool isOSMDoneLoading = false;
bool showArrow = false;
vector <t_point> clean_names;
bool hit_search;
string typed_text = "";

std::vector<unsigned> drawPoifromname(string poiname);
t_bound_box initial_coords;

unordered_map <string, vector<unsigned>> POItype_by_POI_id;

Surface demo=  load_png_from_file("libstreetmap/resources/arrow_left.png");
Surface bank=  load_png_from_file("libstreetmap/resources/small_image.png");
Surface hospital= load_png_from_file("libstreetmap/resources/arrow_inout.png");



std::vector<std::vector<LatLon>> OSMBuildings;
std::vector<unsigned>POIIDS;
vector<unsigned> found_POI_id;

double greatestLattitude, smallestLattitude;
double greatestLongitude, smallestLongitude;



vector <unsigned> intersections;
bool show_highlighted_intersections = false;
bool show_highlighted_POI = false;
#define ZOOM_LEVEL 0.0001

//Calculate the window size based on latitude and longitude values
LatLon getAvgLatLon() {
    LatLon current;
    double latSum = 0;
    double lonSum = 0;
    double lat, lon;
    
    //Initialize the first position point to greatest lat and Lon values
    greatestLattitude = smallestLattitude = getIntersectionPosition(0).lat();
    greatestLongitude = smallestLongitude = getIntersectionPosition(0).lon();

    //Loop through all the interested points and make comparison between the current points and greatest Lat&Lon values
    for (unsigned i = 0; i < getNumberOfIntersections(); i++) {
        current = getIntersectionPosition(i);
        latSum += current.lat();
        lonSum += current.lon();
        if (current.lat() > greatestLattitude) greatestLattitude = current.lat();
        if (current.lon() > greatestLongitude) greatestLongitude = current.lon();
        if (current.lat() < smallestLattitude) smallestLattitude = current.lat();
        if (current.lon() < smallestLongitude) smallestLongitude = current.lon();
    }
    
    //Take the average of all the interest points of the map display 
    lat = latSum / getNumberOfIntersections();
    lon = -lonSum / getNumberOfIntersections();
    LatLon avgLatLon(lat, lon);
    
    //Decide for the actual size of the map display
    LatLon positionRightTop(greatestLattitude, greatestLongitude);
    LatLon positionLeftBottom(smallestLattitude, smallestLongitude);
    
    //Set the initial coordinates of the map
    initial_coords = t_bound_box(getAbsoluteXYPos(positionLeftBottom).x,
            getAbsoluteXYPos(positionLeftBottom).y,
            getAbsoluteXYPos(positionRightTop).x,
            getAbsoluteXYPos(positionRightTop).y);
    return avgLatLon;

}

void draw_map() {

    /**************** initialize display **********************/

    // Set-up coordinates. The coordinates passed in define what coordinate
    // limits you want to use; this coordinate system is mapped to fill 
    // the screen.
    getAvgLatLon();
    init_graphics("Maps Graphics", WHITE);

    set_visible_world(initial_coords);
    set_drawing_buffer(OFF_SCREEN);
    POItype_by_POI_id_preload(POItype_by_POI_id);

    update_message("");

    create_button("Window", "0 Clicks", act_on_new_button_func); // name is UTF-8 
    create_button("0 Clicks", "POI", act_on_POI);
    // Enable mouse movement (not just button presses) and key board input.
    // The appropriate callbacks will be called by event_loop.

    set_mouse_move_input(true);
    drawscreen();
    //  set_coordinate_system(GL_SCREEN);
    event_loop(act_on_button_press, NULL, act_on_key_press, drawscreen);
    // event_loop(act_on_mousebutton, NULL, act_on_keypress, drawscreen);            
    close_graphics();
    std::cout << "Graphics closed down.\n";
}

//Draws the features included in the map
void drawscreen(void) {
    set_drawing_buffer(OFF_SCREEN);
    set_coordinate_system(GL_WORLD);
    set_draw_mode(DRAW_NORMAL);
    clearscreen();
    drawWaterBodies();
    drawIslands();
    drawGreenery();
    drawRiver();
    
    showArrow = false;
 
    draw_highlighted_POI();
    
    if (get_visible_world().area() < 1.8e-7) {
        drawBuildingsAndUnknown(); // Draws buildings and unknown features
        showArrow = true;
        drawMinorStreetSegments();
        drawRegularStreetSegments();
        drawMajorStreetSegments();
        drawMinorNames();
        drawPOIbyType("bank");
        //drawPOIbyType("restaurant");
        
    } else if (get_visible_world().area() < 5.2e-7) {
        drawBuildingsAndUnknown(); // Draws buildings and unknown features
        showArrow = true;
        drawRegularStreetSegments();
        drawMajorStreetSegments();
        setfontsize(7);
        drawRegularNames(); 
        setfontsize(8);
        drawMajorNames();
        drawPOIbyType("hospital");
        drawPOIbyType("university");
       
    } else if (get_visible_world().area() < 1.4e-6) {
        drawBuildingsAndUnknown(); // Draws buildings and unknown features
        drawRegularStreetSegments();
        drawMajorStreetSegments(); 
        setfontsize(8);
        drawMajorNames();
        drawPOIbyType("hospital");
        drawPOIbyType("university");

    } else if (get_visible_world().area() < 4.1e-6) {
        drawBuildingsAndUnknown(); // Draws buildings and unknown features
        drawRegularStreetSegments();
        drawMajorStreetSegments();
        setfontsize(8);
        drawMajorNames();
      
    } else if (get_visible_world().area() < 1.1e-5) {
        drawBuildingsAndUnknown(); // Draws buildings and unknown features
        drawMajorStreetSegments();
   
    } else if (get_visible_world().area() < 3.2e-5) {
        drawBuildingsAndUnknown(); // Draws buildings and unknown features
         drawMajorStreetSegments();
    }
    drawFreeWayStreetSegments();
    drawFreeWayNames();
    draw_highlighted_intersections();
    drawSearchBox();
    copy_off_screen_buffer_to_screen();

    set_coordinate_system(GL_SCREEN);
}


void act_on_button_press(float x, float y, t_event_buttonPressed event) {
    intersections.clear();
    show_highlighted_intersections = false;
    drawscreen();
    t_point world;
    world.x = x;
    world.y = y;
    t_point screen = visibleWorldToVisibleScreen(world);
    //hit the search bar
    if (screen.x > get_visible_screen().right() - 40 - TEXTBOX_LENGTH && screen.x < get_visible_screen().right() - 40 && screen.y > 20 && screen.y < 20 + TEXTBOX_WIDTH) {
        hit_search = true;
        set_keypress_input(true);
        set_drawing_buffer(ON_SCREEN);
        drawSearchBox();
    }
    //check if hit intersection
    else {
        hit_search = false;
        set_keypress_input(false);
        typed_text = "";
        set_drawing_buffer(ON_SCREEN);
        drawSearchBox();
        t_point clicked;
        clicked.x = x;
        clicked.y = y;
        unsigned closest_intersection = find_closest_intersection(getLatLon (clicked));
        float length = getAbsoluteXYLength((getAbsoluteXYPos(getIntersectionPosition(closest_intersection))), clicked);
        //if distance from intersection to clicked is close enough
        if (length < 3e-06){
            intersections.push_back(closest_intersection);
            search_found();
        }
    }
}

//panns & zooms to searched intersection, including all intersections
void search_found() {
    show_highlighted_intersections = true;
    set_drawing_buffer(ON_SCREEN);
    draw_highlighted_intersections();
    set_drawing_buffer (OFF_SCREEN);
    t_point center;
    center.x = 0;
    center.y = 0;
    t_point furthest;
    for (unsigned x = 0; x < intersections.size(); x++) {
        center += getAbsoluteXYPos(getIntersectionPosition(intersections[x]));
    }

    center.x = center.x / intersections.size();
    center.y = center.y / intersections.size();

    if (intersections.size() == 1) {

        set_visible_world(center.x - ZOOM_LEVEL, center.y - ZOOM_LEVEL, center.x + ZOOM_LEVEL, center.y + ZOOM_LEVEL, false);
    } else {
        furthest = center;
        for (unsigned x = 0; x < intersections.size(); x++) {
            if (getAbsoluteXYLength(center, furthest) < getAbsoluteXYLength(center, getAbsoluteXYPos(getIntersectionPosition(intersections[x])))) {
                furthest = getAbsoluteXYPos(getIntersectionPosition(intersections[x]));
            }
        }
        //void set_visible_world(float left, float bottom, float right, float top) 
     //   cout << furthest.x << " " << furthest.y << " " << intersections.size() << endl;
        furthest.x = abs(center.x - furthest.x);
        furthest.y = abs(center.y - furthest.y);
        if (furthest.x > ZOOM_LEVEL || furthest.y > ZOOM_LEVEL)
            set_visible_world(center.x - furthest.x - ZOOM_LEVEL / 10, center.y - furthest.y - ZOOM_LEVEL / 10, center.x + furthest.x + ZOOM_LEVEL / 10, center.y + furthest.y + ZOOM_LEVEL / 10, false);
        else
            set_visible_world(center.x - ZOOM_LEVEL, center.y - ZOOM_LEVEL, center.x + ZOOM_LEVEL, center.y + ZOOM_LEVEL, false);
    }
    drawscreen();

}

//parses user input & sees if intersection exists
void search_intersection() {
    intersections.clear(); //global variable which i am storing the every intersection matching the name of the intersection
    //it is being cleared because this function is triggered if the user presses enter
    //it wants to flush the past intersection which was searched for
    //this global variable is later used to figure out where to draw the red circle
    settextrotation(0); //make sure we are writing horizontally
    auto ampersand = typed_text.find("&"); //we know each intersection has the &
    if (ampersand == string::npos) { //if it isn't found then it is invalid format, string::npos is a constant which is returned when not found
     //   cout << "Invalid format" << endl;
        update_message("Invalid format, please include & between street names, ex. Eglinton Avenue East & Yonge Street");
    } else {
        string street1 = typed_text.substr(0, ampersand); //substring works like [) including first, and excluding last
        string street2 = typed_text.substr(ampersand + 2);
        trim(street1); //trim gets rid of spaces
        trim(street2);

        intersections = find_intersection_ids_from_street_names(street1, street2);
        if (intersections.size() == 0) {
            
            update_message("Intersection does not exist."); //message on bottom of screen
        } else {
            
            search_found();

        }
    }
}
    
void search_intersection_to_intersection(){
    settextrotation(0);
    auto to = typed_text.find(" to ");
    if (to == string::npos){
        update_message("Invalid format, please include keyword ' to ' in your query, ex. Eglinton Avenue East & Yonge Street to");
    }
    else{
        string intersection1 = typed_text.substr (0, to);
        string intersection2 = typed_text.substr (to + 4);
        auto ampersand1 = intersection1.find ("&");
        auto ampersand2 = intersection2.find ("&");
        if (ampersand1 == string::npos || ampersand2 == string::npos){
            update_message("Invalid format, please include & between street names, ex. Eglinton Avenue East & Yonge Street");
        }
        else {
            string intersection1_street1 = intersection1.substr(0,ampersand1);
            string intersection1_street2 = intersection1.substr(ampersand1 + 2);
            trim (intersection1_street1);
            trim (intersection1_street2);
            vector <unsigned> intersections1 = find_intersection_ids_from_street_names(intersection1_street1, intersection1_street2);
            string intersection2_street1 = intersection2.substr(0,ampersand2);
            string intersection2_street2 = intersection2.substr(ampersand2 + 2);
            trim (intersection2_street1);
            trim (intersection2_street2);
            vector <unsigned> intersections2 = find_intersection_ids_from_street_names(intersection2_street1, intersection2_street2);
            if (intersection1.size() == 0) {
                string msg = intersection1_street1 + " & " + intersection1_street2 + " does not exist.";
                update_message(msg);
            }
            else if (intersection2.size() == 0) {
                string msg = intersection2_street1 + " & " + intersection2_street2 + " does not exist.";
                update_message(msg);
            }
            else{
                search_intersection_to_intersection_exists (intersection1[0],intersection2[0]);
            }
            
        }
    }
   
}

void search_intersection_to_POI(){
    settextrotation(0);
    auto to = typed_text.find(" to ");
    if (to == string::npos){
        update_message("Invalid format, please include keyword ' to ' in your query, ex. Eglinton Avenue East & Yonge Street to");
    }
    else {
        string intersection1 = typed_text.substr (0, to);
        string POI_name = typed_text.substr (to + 4);
        auto ampersand = intersection1.find ("&");
        trim (POI_name);
        vector <unsigned> POIs =  getPointOfInterestID(POI_name);
        if (ampersand == string::npos){
            update_message("Invalid format, please include & between street names, ex. Eglinton Avenue East & Yonge Street");
        }
        else if (POIs.size() == 0){
            string msg = "The point of interest, " + POI_name + "does not exist on this map";
            update_message(msg);
        }
        else {
            string intersection1_street1 = intersection1.substr(0,ampersand);
            string intersection1_street2 = intersection1.substr(ampersand + 2);
            trim (intersection1_street1);
            vector <unsigned> intersections1 = find_intersection_ids_from_street_names(intersection1_street1, intersection1_street2);
            if (intersection1.size() == 0) {
                string msg = intersection1_street1 + " & " + intersection1_street2 + " does not exist.";
                update_message(msg);
            }
            else {
                search_intersection_to_POI_exists (intersection1[0],POI_name);
            }
            
        }
    }
    
    
    //similar to intersection_to_intersection, but will need to check if POI name exists (jerry should have made a function for this)
    //call the search_intersection_to_POI_exists
}

void search_intersection_to_intersection_exists (unsigned intersectionId1, unsigned intersectionId2){
    cout << intersectionId1 << " " << intersectionId2 <<endl;
    //for future,
    //call find_path_between_intersections, save the vector & put it in draw path, with the start & end as well as any term penalty you want which will return a vector of street segment ids
    //call draw_path
    
}

void search_intersection_to_POI_exists (unsigned intersectionId1, string POI){
    cout << intersectionId1 << " " << POI <<endl;
    
    //for future,
    //call find_path_to_point_of_interest, save the vector & put it in draw path with the start & end as well as any term penalty you want which will return a vector of street segment ids
    //call draw_path
}

void draw_path (std::vector<unsigned> street_segments_in_path){
    //draw here
}

//reads in user input until enter, allows backspace
void act_on_key_press(char c, int keysym) {
    if (keysym == XK_Return) { //user hit enter
        set_keypress_input(false); //no longer listens to keyboard input
        auto path_input = typed_text.find("PATH:"); //if command is path finding
        auto poi_input = typed_text.find("POI:"); //if command is POI finding
        if (typed_text.substr (0,5) == "PATH:" ){
            typed_text = typed_text.substr (5);
            search_intersection_to_intersection();
        }
        else if (typed_text.substr (0,4) == "POI:"){
            typed_text = typed_text.substr (4);
            search_intersection_to_POI(); //tells program to search for the intersection
        }
        else{
            search_intersection();
        }
            
        typed_text = ""; //sets the typed text back to nothing
        hit_search = false; //lets program know that user clicked search bar
    } else if (keysym == XK_BackSpace && typed_text.length() > 0) { //user has hit backspace & there is already something typed
        typed_text = typed_text.substr(0, typed_text.length() - 1); //removes last character
    } else {
        if ((c >= 32 && c <= 126)) { //limits ascii
            typed_text = typed_text + char(c);
        }
    }
    set_drawing_buffer(ON_SCREEN); //changes buffer to on_screen 
    drawSearchBox(); //search box is now being drawn immediately on screen
}

//draws circles on intersections & prints intersection information on the bottom
void draw_highlighted_intersections() {
    if (show_highlighted_intersections) {
       // set_drawing_buffer (ON_SCREEN);
        string bottom_text = "";
        setcolor(RED);
        setlinewidth(3);
        for (unsigned x = 0; x < intersections.size(); x++) {
           // cout << getAbsoluteXYPos(getIntersectionPosition(intersections[x])).x << " " << getAbsoluteXYPos(getIntersectionPosition(intersections[x])).y << endl;
            drawarc(getAbsoluteXYPos(getIntersectionPosition(intersections[x])).x, getAbsoluteXYPos(getIntersectionPosition(intersections[x])).y, 0.000004, 0, 360);
            //getIntersectionName(IntersectionIndex intersectionIdx);
            bottom_text = bottom_text + "   " + "Intersection Name: " + getIntersectionName(intersections[x]) + "   "
                    + "Lat: " + to_string(getIntersectionPosition(intersections[x]).lat()) + "   " + "Lon: " + to_string(getIntersectionPosition(intersections[x]).lon());
            update_message(bottom_text);
        }
     //   set_drawing_buffer(OFF_SCREEN);
    } else {
        update_message("");
    }
}


// Converts a given LatLon into a xy position to draw on the screen 
t_point getAbsoluteXYPos(LatLon position) {

    t_point convXY;
    float latAvg = DEG_TO_RAD * (greatestLattitude + smallestLattitude) / 2;
    convXY.x = (DEG_TO_RAD * position.lon() * cos(latAvg));
    convXY.y = DEG_TO_RAD * position.lat();
    return convXY;
}

//converts XYPos back to LatLon
LatLon getLatLon (t_point XYPos){
    float latAvg = DEG_TO_RAD * (greatestLattitude + smallestLattitude) / 2;
    LatLon pos(XYPos.y/DEG_TO_RAD, XYPos.x/(DEG_TO_RAD * cos (latAvg)));
    return pos;
    
}

//converts world coords to screen coords
t_point visibleWorldToVisibleScreen(t_point visible_world) {
    float y_screen_over_world = get_visible_screen().get_height() / get_visible_world().get_height();
    float x_screen_over_world = get_visible_screen().get_width() / get_visible_world().get_width();

    //find offset
    float top_world_to_screen = get_visible_world(). top() * y_screen_over_world;
    float left_world_to_screen = get_visible_world(). left() * x_screen_over_world;

    float y_offset = get_visible_screen().top() - top_world_to_screen;
    float x_offset = get_visible_screen().left() - left_world_to_screen;
    //t_point offset = get_visible_screen().top_right() - get_visible_world().top_right();
    t_point on_screen;
    on_screen.x = visible_world.x * x_screen_over_world + x_offset;
    on_screen.y = visible_world.y * y_screen_over_world + y_offset;
    return on_screen;

}

//get length between any two points
double getAbsoluteXYLength(t_point p1, t_point p2) {
    return sqrt((p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y));
}


//draws the search box with initial text & user input
void drawSearchBox() {
    drawTextBox(get_visible_screen().right() - 40 - TEXTBOX_LENGTH, 20);
    set_coordinate_system(GL_SCREEN); //coordinate system is set to screen
    setfontsize(10);
    settextrotation(0);
    if (!hit_search) {
        setcolor(LIGHTGREY);
        string search_text = "Search (ex. Eglinton Avenue East & Yonge Street)";
        drawtext(get_visible_screen().right() - 40 - TEXTBOX_LENGTH + 10, 20 + 10, search_text, FLT_MAX, FLT_MAX, false);
    } else {
        setcolor(BLACK);
        if (typed_text.length() < 48)
            drawtext(get_visible_screen().right() - 40 - TEXTBOX_LENGTH + 10, 20 + 10, typed_text, FLT_MAX, FLT_MAX, false);
        else
            drawtext(get_visible_screen().right() - 40 - TEXTBOX_LENGTH + 10, 20 + 10, typed_text.substr(typed_text.length()-47), FLT_MAX, FLT_MAX, false);
    }
    set_coordinate_system(GL_WORLD);
}

//draws the background for textbox
void drawTextBox(float x_topleft, float y_topleft) {
    set_coordinate_system(GL_SCREEN);
    setcolor(WHITE);
    fillrect(x_topleft, y_topleft, x_topleft + TEXTBOX_LENGTH, y_topleft + TEXTBOX_WIDTH);
    setcolor(DARKGREY);
    setlinewidth(3);
    drawrect(x_topleft, y_topleft, x_topleft + TEXTBOX_LENGTH, y_topleft + TEXTBOX_WIDTH);
    set_coordinate_system(GL_WORLD);
}

//draws minor streets, show up only if a width is large enough
void drawMinorStreetSegments() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) - 4;
    if (width > 1) {
        setcolor(LIGHTGREY);
        setlinewidth(width);
        vector<unsigned int> minor = find_street_segment_street_by_type("minor");
        for (unsigned int x = 0; x < minor.size(); x++) {
            drawingStreetSegments(minor[x]);
        }
    }
}

//draws regular streets, show up only if a width is large enough
void drawRegularStreetSegments() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) - 1;
    if (width > 1) {
        setcolor(DARKGREY);
        setlinewidth(width);
        vector<unsigned int> regular = find_street_segment_street_by_type("regular");
        for (unsigned int x = 0; x < regular.size(); x++) {
            drawingStreetSegments(regular[x]);
        }
        setcolor(YELLOW);
        vector<unsigned int> link = find_street_segment_street_by_type("link");
        for (unsigned int x = 0; x < link.size(); x++) {
            drawingStreetSegments(link[x]);
        }
    }
}

//draws major streets, show up only if a width is large enough
void drawMajorStreetSegments() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 1;
    if (width > 2) {
        setcolor(DARKGREY);
        setlinewidth(width);
        vector<unsigned int> major = find_street_segment_street_by_type("major");
        for (unsigned int x = 0; x < major.size(); x++) {
            drawingStreetSegments(major[x]);
        }
    }
}

//draws highways
void drawFreeWayStreetSegments() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    setcolor(ORANGE);
    setlinewidth(width);
    vector<unsigned int> freeways = find_street_segment_street_by_type("freeway");
    for (unsigned int x = 0; x < freeways.size(); x++) {
        drawingStreetSegments(freeways[x]);
    }
}

//helper function to draw street segments
void drawingStreetSegments(unsigned int x) {
    StreetSegmentInfo currStreetSegment = getStreetSegmentInfo(x);
    t_point from = getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.from));		
    t_point to = getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.to));
    if (currStreetSegment.curvePointCount == 0) {
        drawline(from, to);
        if (currStreetSegment.oneWay && showArrow) {
            draw_arrow(from, to);
        }
    } else {
        drawline(getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.from)), getAbsoluteXYPos(getStreetSegmentCurvePoint(x, 0)));
        for (unsigned y = 0; y < currStreetSegment.curvePointCount - 1; y++) {
            drawline(getAbsoluteXYPos(getStreetSegmentCurvePoint(x, y)), getAbsoluteXYPos(getStreetSegmentCurvePoint(x, y + 1)));
        }
        drawline(getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.to)), getAbsoluteXYPos(getStreetSegmentCurvePoint(x, currStreetSegment.curvePointCount - 1)));
    }
}

//arrow for one way streets
void draw_arrow(t_point &from, t_point &to) {
    t_color temp_color = getcolor();
    t_bound_box arrow((from.x) - 0.03, (from.y) - 0.03, (from.x) + 0.03, (from.y) + 0.03);		
    setcolor(LIMEGREEN);			
    settextrotation(setRotation(from, to));
    drawtext_in(arrow, "->");
    setcolor(temp_color);
}

//rotation function for one way street arrows
double setRotation(t_point &from, t_point &to) {		
    if (from.x == to.x) return 0;
    double angle = atan((to.y - from.y) / (to.x - from.x)) * 180 / PI;		
    //if (angle < 0.0) angle += 360;
    return angle;
}


//draw minor street names
void drawMinorNames() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 1;
    if (width > 6) {
        setcolor(BLACK);


        vector<unsigned int> minor = find_street_segment_street_by_type("minor");
        for (unsigned int x = 0; x < minor.size(); x = x + 3) {
            StreetSegmentInfo currStreetSegment = getStreetSegmentInfo(minor[x]);
            if (getStreetName(currStreetSegment.streetID) != "<unknown>") {

                t_point from = getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.from));
                t_point to = getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.to));
                t_point middle;
                middle.x = (from.x + to.x) / 2;
                middle.y = (from.y + to.y) / 2;
                setfontsize(7);
                if (to.x - from.x < 0) {
                    settextrotation(asin((-to.y + from.y) / getAbsoluteXYLength(to, from))*180.0 / PI);
                } else {
                    settextrotation(asin((to.y - from.y) / getAbsoluteXYLength(to, from))*180.0 / PI);
                }
                drawtext(middle, getStreetName(currStreetSegment.streetID), 0.001, 0.001);
            }
        }
        clean_names.clear();
    }
}

//draw regular street names
void drawRegularNames() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    if (width > 6) {
        setcolor(BLACK);

        vector<unsigned int> regular = find_street_segment_street_by_type("regular");
        for (unsigned int x = 0; x < regular.size(); x = x + 3) {
            StreetSegmentInfo currStreetSegment = getStreetSegmentInfo(regular[x]);
            if (getStreetName(currStreetSegment.streetID) != "<unknown>") {

                drawingStreetNames(currStreetSegment, get_visible_world().get_width(), "regular");
            }
        }
        clean_names.clear();
    }
}

//draws major names
void drawMajorNames() {
    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 3;
    if (width > 6) {
        setcolor(BLACK);

        //setfontsize(width);
        vector<unsigned int> major = find_street_segment_street_by_type("major");
        for (unsigned int x = 0; x < major.size(); x++) {
            StreetSegmentInfo currStreetSegment = getStreetSegmentInfo(major[x]);
            if (getStreetName(currStreetSegment.streetID) != "<unknown>") {

                drawingStreetNames(currStreetSegment, get_visible_world().get_width(), "major");
            }
        }
        clean_names.clear();
    }
}

//draws freeway names
void drawFreeWayNames() {

    int width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    setcolor(BLACK);
    if (get_visible_world().get_width() > 0.002)
        setfontsize(width + 3);
    else if (get_visible_world().get_width() > 0.001)
        setfontsize(width + 2);
    else
        setfontsize(width);
    vector<unsigned int> freeways = find_street_segment_street_by_type("freeway");
    for (unsigned int x = 0; x < freeways.size(); x++) {
        StreetSegmentInfo currStreetSegment = getStreetSegmentInfo(freeways[x]);
        if (getStreetName(currStreetSegment.streetID) != "<unknown>") {

            drawingStreetNames(currStreetSegment, get_visible_world().get_width(), "freeway");
        }
    }
    clean_names.clear();
}

//draws street names based on rotation
void drawingStreetNames(StreetSegmentInfo currStreetSegment, double width, string type) {
    // if (currStreetSegment.curvePointCount == 0) {
    t_point from = getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.from));
    t_point to = getAbsoluteXYPos(getIntersectionPosition(currStreetSegment.to));
    //      cout << getAbsoluteXYLength(to, from) << " " << width << endl;
    if (checkCleanNames((to.x + from.x) / 2, (to.y + from.y) / 2, width, type)) {
        if (to.x - from.x < 0) {
            settextrotation(asin((-to.y + from.y) / getAbsoluteXYLength(to, from))*180.0 / PI);
        } else {
            settextrotation(asin((to.y - from.y) / getAbsoluteXYLength(to, from))*180.0 / PI);
        }
        drawtext((to.x + from.x) / 2, (to.y + from.y) / 2, getStreetName(currStreetSegment.streetID), FLT_MAX, FLT_MAX);
    }
}

// prevents too much overlap of names by limiting distance
bool checkCleanNames(double x, double y, double width, string type) {
    double use_width;
    if (type == "freeway") {
        use_width = width / 8;
    } else if (type == "major") {
        use_width = width / 12;
    } else if (type == "minor") {
        use_width = width / 14;
    } else {
        use_width = width / 13;
    }
    for (unsigned i = 0; i < clean_names.size(); i++) {
        t_point temp;
        temp.x = x;
        temp.y = y;

        if (getAbsoluteXYLength(clean_names[i], temp) < use_width) {
            return false;
        }
    }
    t_point temp;
    temp.x = x;
    temp.y = y;
    clean_names.push_back(temp);
    return true;
}


//Iterates through all the features and draws green spaces
void drawGreenery() {
    unsigned featureCount = getNumberOfFeatures();
    for (unsigned i = 0; i < featureCount; i++) {
        // Check for park(1), greenspace(8), golfcourse(9)
        if (getFeatureType(i) == 1 ) {
            setcolor(TURQUOISE);
            setlinewidth(5);
            drawPolygon(getFeaturePointCount(i), i);
           
        }
        else if ( getFeatureType(i) == 8) {
            setcolor(GREEN);
             setlinewidth(5);
            drawPolygon(getFeaturePointCount(i), i);
        }
        else if ( getFeatureType(i) == 9) {
             setlinewidth(5);
            setcolor(DARKGREEN);
            drawPolygon(getFeaturePointCount(i), i);
        }
          
        
    }
}

//Iterates through all the features and draws water bodies
void drawWaterBodies() {
    unsigned featureCount = getNumberOfFeatures();
    for (unsigned i = 0; i < featureCount; i++) {
       if (getFeatureType(i) == 2 ) {    
            setlinewidth(2);
            setcolor(YELLOW);   //Beach
            drawPolygon(getFeaturePointCount(i), i);
        }
        else if (getFeatureType(i) == 3 ) {    
            setlinewidth(2);
            setcolor(BLUE);  //Lake,
            drawPolygon(getFeaturePointCount(i), i);
        }
        else if (getFeatureType(i) == 4) {    
            setlinewidth(1);
            setcolor(DARKSLATEBLUE);//River,
            drawPolygon(getFeaturePointCount(i), i);
        }
        
             
        else if (getFeatureType(i) == 10) {    
            setlinewidth(1);
            setcolor(LIGHTMEDIUMBLUE);   //Stream
            drawPolygon(getFeaturePointCount(i), i);
        }      

}
}

//Iterates through all the features and draws islands
void drawIslands() {
    unsigned featureCount = getNumberOfFeatures();
    for (unsigned i = 0; i < featureCount; i++) {
        // check for island(5)
        if (getFeatureType(i) == 5) {
            setlinewidth(3);
            setcolor(DARKGREEN);
            drawPolygon(getFeaturePointCount(i), i);
        }
        else if (getFeatureType(i) == 6) {     // Shoreline
            setlinewidth(2);
            setcolor(SADDLEBROWN);//
            drawPolygon(getFeaturePointCount(i), i);
        }
        

    }
}

void drawRiver() {
    unsigned featureCount = getNumberOfFeatures();
    for (unsigned i = 0; i < featureCount; i++) {
       
        if(getFeatureType(i) == 4) {    
            setlinewidth(2);
            setcolor(DARKSLATEBLUE);//River,
            drawPolygon(getFeaturePointCount(i), i);
        }
 
        else if (getFeatureType(i) == 10) {    
            setlinewidth(1);
            setcolor(LIGHTMEDIUMBLUE);   //Stream
            drawPolygon(getFeaturePointCount(i), i);
        }      

}
}

//draws  building or  unknown.
void drawBuildingsAndUnknown() {
    unsigned featureCount = getNumberOfFeatures();

    for (unsigned i = 0; i < featureCount; i++) {
        if (getFeatureType(i) == 7) {
             setlinewidth(2);
            setcolor(LIGHTGREY);
            drawPolygon(getFeaturePointCount(i), i);
        }// Unknown 
        else if (getFeatureType(i) == 0) {
            setlinewidth(2);
            setcolor(BISQUE);
            drawPolygon(getFeaturePointCount(i), i);
        }

    }
}




 // Does the same as the below function 
// first gets the coordinates from features points and its ids
void drawPolygon(unsigned featurePoints, unsigned featureId) {
    unsigned i = 0;
    LatLon start = getFeaturePoint(featureId, i);
    LatLon end = getFeaturePoint(featureId, featurePoints - 1);
    std::vector<t_point> featurePointsXY;

    bool polygon = false;
    featurePointsXY.push_back(getAbsoluteXYPos(start));
    if ((start.lat() == end.lat()) && (start.lon() == end.lon())) {
        polygon = true;
    }

    for (i = 1; i < featurePoints; i++) {
        LatLon coordinates = getFeaturePoint(featureId, i);
        // featurePointsXY[i] = getAbsoluteXYPos(coordinates);
        featurePointsXY.push_back(getAbsoluteXYPos(coordinates));
        if (polygon == false) {
            //setlinewidth(3);
            drawline(featurePointsXY[i - 1], featurePointsXY[i]);
        }
    }
    if (polygon == true) {
        fillpoly(&featurePointsXY[0], featurePoints);
    }
    featurePointsXY.clear();
}

// Second gets the coordinates from LatLon points
void drawPolygon(std::vector<LatLon> points) {
    bool polygon = false;
    std::vector<t_point> featurePointsXY;
    //Checks here if it is a polygon or a line
    if ((points[0].lat() == points[points.size() - 1].lat()) && (points[0].lon() == points[points.size() - 1].lon())) {
        polygon = true;
    }
    unsigned i = 0;
    // change  Points_XY to Absolute_PosPointsXY [points.size()];
    featurePointsXY.push_back(getAbsoluteXYPos(points[0]));
    for (i = 1; i < points.size(); i++) {
        featurePointsXY.push_back(getAbsoluteXYPos(points[i]));
        if (polygon == false) {
            setlinewidth(3);
            drawline(featurePointsXY[i - 1], featurePointsXY[i]);
        }
    }
    //Draws that multi-sided figure
    if (polygon == true) {
        fillpoly(&featurePointsXY[0], points.size());

    }
    featurePointsXY.clear();
}



//Draw any other POIs.
void drawPointofInterest(unsigned POI_id, float rad, color_types color_1, color_types color_2) {
    LatLon position = getPointOfInterestPosition(POI_id);
    t_point POI_position = getAbsoluteXYPos(position);
    setcolor(color_1);
    fillarc(POI_position, rad, 0, 360);
    setcolor(color_2);
    fillarc(POI_position, rad / 2, 0, 360);
}

//Unordered map for associating types with POI_id.
void POItype_by_POI_id_preload(unordered_map <string, vector<unsigned>> &POItype_by_POI_ids) {
    for (unsigned i = 0; i < getNumberOfPointsOfInterest(); i++) {
        string POI_type = getPointOfInterestType(i);
        auto existing_type = POItype_by_POI_ids.find(POI_type);
        if (existing_type == POItype_by_POI_ids.end()) {
            vector<unsigned>temp_type;
            temp_type.push_back(i);
            POItype_by_POI_ids.insert(make_pair(POI_type, temp_type));
        } else {
            existing_type->second.push_back(i);
        }
    }
}

vector<unsigned> get_POI_id_by_POItype(string type) {
    vector<unsigned> POI_id;
    if (POItype_by_POI_id.count(type) > 0) {
        POI_id = POItype_by_POI_id.find(type)->second;
    }
    return POI_id;
}
//These following functions are used for drawing different types of POI in different levels
//of scales.

void drawPOIbyType(string type) {
    vector<unsigned> POI_id = get_POI_id_by_POItype(type);
    if (POI_id.size() > 0) {
        if (type == "fast_food" || type == "food_court" || type == "restaurant")
            drawSustenance(POI_id);
        else if (type == "college" || type == "school" || type == "university")
            drawEducation(POI_id);
        else if (type == "bus_station" || type == "ferry_terminal")
            drawTransportation(POI_id);
        else if (type == "bank")
            drawFinancial(POI_id);
        else if (type == "clinic" || type == "doctors" || type == "hospital")
            drawHealthcare(POI_id);
        else {
            for (auto iter = POI_id.begin(); iter != POI_id.end(); iter++) {
                drawPointofInterest(*iter, 0.00005, KHAKI, WHITE);
            }
        }
    }
}

void drawPOIName(t_point POI_position, unsigned POI_id) {
    string name = getPointOfInterestName(POI_id);
    if (name != "<noname>") {
        setcolor(BLACK);
        setfontsize(7);
        float offset = abs(xscrn_to_world(12) - xscrn_to_world(0));		
        drawtext(POI_position.x, POI_position.y + offset, name, 0.001, 0.001);
    }
}

void drawSustenance(vector<unsigned> POI_id) {
    float width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    for (auto iter = POI_id.begin(); iter != POI_id.end(); iter++) {
        LatLon position = getPointOfInterestPosition(*iter);
        t_point POI_position = getAbsoluteXYPos(position);
        setcolor(YELLOW);
        fillarc(POI_position, 0.0000035, 0, 360);
        setcolor(WHITE);
        t_bound_box text((POI_position.x) - 0.00008, (POI_position.y) - 0.00008,
                (POI_position.x) + 0.00008, (POI_position.y) + 0.00008);
        settextrotation(0);
        setfontsize(width);
        drawtext_in(text, ":)");
        drawPOIName(POI_position, *iter);
    }
}

void drawEducation(vector<unsigned> POI_id) {
    float width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    for (auto iter = POI_id.begin(); iter != POI_id.end(); iter++) {
        LatLon position = getPointOfInterestPosition(*iter);
        t_point POI_position = getAbsoluteXYPos(position);
        setcolor(LIGHTSKYBLUE);
        fillarc(POI_position, 0.0000035, 0, 360);
        setcolor(WHITE);
        t_bound_box text((POI_position.x) - 0.00008, (POI_position.y) - 0.00008,
                (POI_position.x) + 0.00008, (POI_position.y) + 0.00008);
        settextrotation(0);
        setfontsize(width);
        drawtext_in(text, "A+");
        drawPOIName(POI_position, *iter);
    }
}

void drawTransportation(vector<unsigned> POI_id) {
    float width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    for (auto iter = POI_id.begin(); iter != POI_id.end(); iter++) {
        LatLon position = getPointOfInterestPosition(*iter);
        t_point POI_position = getAbsoluteXYPos(position);
        setcolor(LIGHTMEDIUMBLUE);
        fillarc(POI_position, 0.0000035, 0, 360);
        setcolor(WHITE);
        t_bound_box text((POI_position.x) - 0.00008, (POI_position.y) - 0.00008,
                (POI_position.x) + 0.00008, (POI_position.y) + 0.00008);
        settextrotation(0);
        setfontsize(width);
        drawtext_in(text, "<==");
        draw_surface(demo, text.get_xcenter(), text.get_ycenter());
        drawPOIName(POI_position, *iter);
    }
}

void drawFinancial(vector<unsigned> POI_id) {
    float width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    for (auto iter = POI_id.begin(); iter != POI_id.end(); iter++) {
        LatLon position = getPointOfInterestPosition(*iter);
        t_point POI_position = getAbsoluteXYPos(position);
        setcolor(LIMEGREEN);
        fillarc(POI_position, 0.0000035, 0, 360);
        setcolor(WHITE);
        t_bound_box text((POI_position.x) - 0.00008, (POI_position.y) - 0.00008,
                (POI_position.x) + 0.00008, (POI_position.y) + 0.00008);
        settextrotation(0);
        setfontsize(width);
        drawtext_in(text, "$");
        //Is it necessary to always show POI's name?
        draw_surface(bank, text.get_xcenter(), text.get_ycenter());
        drawPOIName(POI_position, *iter);
    }
}

void drawHealthcare(vector<unsigned> POI_id) {
    float width = 2 * sqrt(1 / (get_visible_world().get_width()*100)) + 2;
    for (auto iter = POI_id.begin(); iter != POI_id.end(); iter++) {
        LatLon position = getPointOfInterestPosition(*iter);
        t_point POI_position = getAbsoluteXYPos(position);
        setcolor(RED);
        fillarc(POI_position, 0.0000035, 0, 360);
        setcolor(WHITE);
        t_bound_box text((POI_position.x) - 0.00008, (POI_position.y) - 0.00008,
                (POI_position.x) + 0.00008, (POI_position.y) + 0.00008);
        settextrotation(0);
        setfontsize(width);
        drawtext_in(text, "+");
        draw_surface(hospital, text.get_xcenter(), text.get_ycenter());
        drawPOIName(POI_position, *iter);
    }
}


//New button for searching a POI
void act_on_POI (void((*drawscreen_ptr) (void))){		
    update_message("Search for a point of interest: ");		
    string name;		
    getline(cin, name);		
    		
    //vector<unsigned> POI_id = getPointOfInterestID(name);		
    found_POI_id = getPointOfInterestID(name);
    if (found_POI_id.size() > 0) {
        show_highlighted_POI = true;
        //draw_highlighted_POI();
    } else {
        cout << "Not Found." << endl;
        update_message(name + " not found.");		
    }
    		
    drawscreen();
}

// Highlights the POI when searched for. 

vector<unsigned> drawPoifromname(string poiname) {
    POIIDS = getPointOfInterestID(poiname);
    for (auto itr = POIIDS.begin(); itr != POIIDS.end(); itr++) {
        LatLon location = getPointOfInterestPosition(*itr);
        drawHighlightedIntersectionAndPOI(location);
    }
    return POIIDS;
}

void draw_highlighted_POI() {
    if (show_highlighted_POI) {
        string bottom_text = "";
        setcolor(YELLOW);
        for (auto i = found_POI_id.begin(); i != found_POI_id.end(); i++) {
            LatLon position = getPointOfInterestPosition(*i);
            t_point POI_position = getAbsoluteXYPos(position);
            fillarc(POI_position, 0.0000035, 0, 360);
            bottom_text = bottom_text + "   " + "Point Of Interest: " + getPointOfInterestName(*i) + "   "
                + "Type: " + getPointOfInterestType(*i);
            cout << "Point Of Interest: " << getPointOfInterestName(*i) << "  Type: " << getPointOfInterestType(*i) << endl;
            
            update_message(bottom_text);
        } 
    } else {
        update_message("");
    }
}

/* Draws a circle highlighted Point of interest with different radius 
 * for different zoom levels */ //continue..........

void drawHighlightedIntersectionAndPOI(LatLon position) {
    t_point location = getAbsoluteXYPos(position);

    fillellipticarc(location.x, location.y, 0.00007, 0.00007, 0, 360);
    flushinput();
}

/* Draws the osm buildings like airport terminals and train stations. 
 * Draws a polygon around a vector of latlons. */
void drawOSMBuildings() {
    setcolor(BLUE);
    for (auto itr = OSMBuildings.begin(); itr != OSMBuildings.end(); itr++) {
        drawPolygon(*itr);
    }
}

//Draws the gas ,hospitals,the different points of interest 
// 
//when the user clicks on the menu.

void drawHospitals() {
    for (unsigned i = 0; i < getNumberOfPointsOfInterest(); i++) {
        if (getPointOfInterestType(i) == "clinic" || getPointOfInterestType(i) == "doctor" || getPointOfInterestType(i) == "hospital") {
            LatLon location = getPointOfInterestPosition(i);
            t_point position = getAbsoluteXYPos(location);
            setcolor(DARKSLATEBLUE);
            drawHighlightedIntersectionAndPOI(location);
            setcolor(BLACK);
            setfontsize(7);
            drawtext(position, getPointOfInterestName(i), 1000, 1000);

        }
    }
}


//Clears all highlighted stuff

void clearAllVectors() {

    POIIDS.clear();

}



vector<unsigned> getPointOfInterestID(std::string pointOfInterestName) {
    vector<unsigned> POI_id;
    for (unsigned i = 0; i < getNumberOfPointsOfInterest(); i++) {
        if (pointOfInterestName == getPointOfInterestName(i))
            POI_id.push_back(i);
    }
    return POI_id;
}