/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/* 
 * File:   m4.cpp
 * Author: caiwei7
 *
 * Created on April 1, 2017, 11:08 PM
 */

/*
#include <cstdlib>
#include <m4.h>
#include <m3.h>
#include <m3_additional.h>
#include <unordered_map>
using namespace std;
//vector of street segment ids which form a legal path
//returns vector size 0 if no legal path

std::vector<unsigned> traveling_courier(const std::vector<DeliveryInfo>& deliveries,
        const std::vector<unsigned>& depots,
        const float turn_penalty) {
  //  bool debug = false;

    vector <unsigned> best_path;
    //start with first depot 
    unsigned try_depot_number = 0;
    unsigned intersection_next = depots[0];







    unordered_map <unsigned, vector<unsigned>> pickup_dropoff_ids;

    //look thru legal pickup & dropoff (O(n) max), if already picked up, only look at dropoff
    //if not picked up, do not look at dropoff
    unordered_set <unsigned> nodes_to_look_at;
    for (unsigned int x = 0; x < deliveries.size(); x++) {
        nodes_to_look_at.insert(deliveries[x].pickUp);

        if (pickup_dropoff_ids.find(deliveries[x].pickUp) == pickup_dropoff_ids.end()) {
            vector<unsigned> first_dropoff;
            first_dropoff.push_back(deliveries[x].dropOff);
            pickup_dropoff_ids.insert(make_pair(deliveries[x].pickUp, first_dropoff));
        } else {
            pickup_dropoff_ids[deliveries[x].pickUp].push_back(deliveries[x].dropOff);
        }



        //if (deliveries[x].pickUp == 64489) {
        //    cout << "im looking at the right one" << endl;
     //       debug = true;
      //  }

    }





    while (nodes_to_look_at.size() > 0) {
        //finds the next legal dropoff/delivery intersection & path to get there
        vector_and_intersection closest_next = modified_Dijkstra(intersection_next,
                nodes_to_look_at,
                turn_penalty);
        //absolutely no path found to any of the remaining nodes, return vector sized o
        if (closest_next.path.size() == 0) {
           // if (debug == true) 
              //  cout << "why does i tenter here?" << intersection_next << endl;
            


            //if its a depot we're checking since we started at depot[0], that is current
            //may need to change later]
            if (intersection_next == depots [0]) {
          //      if (debug == true)

        //            cout << "should enter here" << intersection_next << endl;
                bool found = false;
                //while we still have depots to check,
                while (try_depot_number < depots.size()) {
                    intersection_next = depots[try_depot_number];
                    try_depot_number++;
                    //changed depot, now find again
                    closest_next = modified_Dijkstra(intersection_next,
                            nodes_to_look_at,
                            turn_penalty);
                    if (closest_next.path.size() != 0) {
                        found = true;
                        break;
                    }
                }
                if (!found) {
                 //   if (debug == true)
                   //     cout << "should not enter here" << intersection_next << endl;
                    vector<unsigned> empty;
                    return empty;
                }

            }
                //while looking for a path there is none
            else {
                vector<unsigned> empty;
                return empty;
            }
        }
        //insert the path to get there into best_path
        best_path.insert(best_path.end(), closest_next.path.begin(), closest_next.path.end());
        intersection_next = closest_next.intersection;
        //need to update the set of nodes to look at, if the closest_next is a
        //pickup, we need to remove current & add the corresponding dropoff.
        //if closest_next is a dropoff, we simply remove current
        nodes_to_look_at.erase(intersection_next);

     //   if (debug && intersection_next == 32523) {
      //      cout << "it reaches here.. " << endl;
       // }
        if (pickup_dropoff_ids.find(intersection_next) != pickup_dropoff_ids.end()) {
            //insert the corresponding dropoff
            for (unsigned int x = 0; x < pickup_dropoff_ids[intersection_next].size(); x++)
                nodes_to_look_at.insert(pickup_dropoff_ids[intersection_next][x]);
            //        if (debug && intersection_next == 32523){
            //      cout << pickup_dropoff_ids [intersection_next] <<" should equal 92242"<<endl;
            // }
        }


    }

    // end with depot closest to last dropoff
    //last visited is currently stored as intersection_next
    unordered_set <unsigned> depot_set;
    for (unsigned int x = 0; x < depots.size(); x++) {
        depot_set.insert(depots[x]);
    }

    vector_and_intersection closest_next = modified_Dijkstra(intersection_next,
            depot_set,
            turn_penalty);

    //insert path from last droppoff to depot
    best_path.insert(best_path.end(), closest_next.path.begin(), closest_next.path.end());
    return best_path;

}

*/