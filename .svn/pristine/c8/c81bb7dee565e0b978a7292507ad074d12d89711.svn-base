#include "m1.h"
#include "StreetsDatabaseAPI.h"

bool load_map(std::string map_name) {

    bool success = loadStreetsDatabaseBIN(map_name);
    //can add more logic here to store information
    loadStreetsDatabaseBIN(map);
    return success;
}

void close_map() {
    //Clean-up your map related data structures here
    //free any other data structures if we decide to use them
    closeStreetDatabase();
}

//Returns street id(s) for the given street name
//If no street with this name exists, returns a 0-length vector.
std::vector<unsigned> find_street_ids_from_name(std::string street_name)

{
    std::vector<unsigned> streetIDs;
    for (int x = 0; x < getNumberOfStreets; x++)
    {
        if street_name == getStreetName (x);
        streetIDs.push_back (x);
    }
    
    
    return streetIDs;
    
}

//Returns the street segments for the given intersection 
std::vector<unsigned> find_intersection_street_segments(unsigned intersection_id)
{
    std::vector<unsigned> empty;
    
    return empty;
}

//Returns the street names at the given intersection (includes duplicate street names in returned vector)
std::vector<std::string> find_intersection_street_names(unsigned intersection_id){
    std::vector<std::string> empty;
    
    return empty;
}

//Returns true if you can get from intersection1 to intersection2 using a single street segment (hint: check for 1-way streets too)
//corner case: an intersection is considered to be connected to itself
bool are_directly_connected(unsigned intersection_id1, unsigned intersection_id2){
    bool empty;
    
    return empty;
}

//Returns all intersections reachable by traveling down one street segment 
//from given intersection (hint: you can't travel the wrong way on a 1-way street)
//the returned vector should NOT contain duplicate intersections
std::vector<unsigned> find_adjacent_intersections(unsigned intersection_id){
    std::vector<unsigned> empty;
    
    return empty;
}

//Returns all street segments for the given street
std::vector<unsigned> find_street_street_segments(unsigned street_id){
    std::vector<unsigned> empty;
    
    return empty;
}

//Returns all intersections along the a given street
std::vector<unsigned> find_all_street_intersections(unsigned street_id){
    std::vector<unsigned> empty;
    
    return empty;
}

//Return all intersection ids for two intersecting streets
//This function will typically return one intersection id.
//However street names are not guarenteed to be unique, so more than 1 intersection id may exist
std::vector<unsigned> find_intersection_ids_from_street_names(std::string street_name1, std::string street_name2){
    std::vector<unsigned> empty;
    
    return empty;
}

//Returns the distance between two coordinates in meters
double find_distance_between_two_points(LatLon point1, LatLon point2){
    double empty;
    
    return empty;
}

//Returns the length of the given street segment in meters
double find_street_segment_length(unsigned street_segment_id){
    double empty;
    
    return empty;
}

//Returns the length of the specified street in meters
double find_street_length(unsigned street_id){
    double empty;
    
    return empty;
}

//Returns the travel time to drive a street segment in seconds (time = distance/speed_limit)
double find_street_segment_travel_time(unsigned street_segment_id){
    double empty;
    
    return empty;
}

//Returns the nearest point of interest to the given position
unsigned find_closest_point_of_interest(LatLon my_position){
    unsigned empty;
    
    return empty;
}

//Returns the the nearest intersection to the given position
unsigned find_closest_intersection(LatLon my_position){
    unsigned empty;
    
    return empty;
}
