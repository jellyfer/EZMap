#include "m3.h"
#include "m1.h"
#include "StreetsDatabaseAPI.h"
using namespace std;

// Returns the time required to travel along the path specified, in seconds. 
// The path is given as a vector of street segment ids, and this function 
// can assume the vector either forms a legal path or has size == 0.
// The travel time is the sum of the length/speed-limit of each street 
// segment, plus the given turn_penalty (in seconds) per turn implied by the path. 
// A turn occurs when two consecutive street segments have different street IDs.
double compute_path_travel_time(const std::vector<unsigned>& path, 
                                const double turn_penalty) {
    double time = 0;
    // If there's an empty path, return 0s.
    if (path.empty()) {
        return time;
    // If there's only one segment, return its travel time.
    } else if (path.size() == 1) {
        time = find_street_segment_travel_time(path[0]);
        return time;
    } else {
        // Calculate the first segment travel time.
        StreetSegmentInfo previousSegment = getStreetSegmentInfo(path[0]);
        time = time  + find_street_segment_travel_time(path[0]);
        for (unsigned int size = 1; size < path.size(); size++) {
            StreetSegmentInfo currentSegment = getStreetSegmentInfo(path[size]);
            double travelTime = find_street_segment_travel_time(path[size]);
            // Check if there's a turn from previous segment and current segment.
            if (previousSegment.streetID == currentSegment.streetID) {
                time = time + travelTime;
            } else {
                time = time + travelTime + turn_penalty;
            }
            previousSegment = currentSegment;
        }
    }
    return time;
}


// Returns a path (route) between the start intersection and the end 
// intersection, if one exists. This routine should return the shortest path
// between the given intersections when the time penalty to turn (change
// street IDs) is given by turn_penalty (in seconds).
// If no path exists, this routine returns an empty (size == 0) vector. 
// If more than one path exists, the path with the shortest travel time is 
// returned. The path is returned as a vector of street segment ids; traversing 
// these street segments, in the returned order, would take one from the start 
// to the end intersection.
vector<unsigned> find_path_between_intersections(const unsigned intersect_id_start, 
                                                      const unsigned intersect_id_end,
                                                      const double turn_penalty) {
    vector <unsigned> empty;
    return empty;
}


// Returns the shortest travel time path (vector of street segments) from 
// the start intersection to a point of interest with the specified name.
// The path will begin at the specified intersection, and end on the 
// intersection that is closest (in Euclidean distance) to the point of 
// interest.
// If no such path exists, returns an empty (size == 0) vector.
std::vector<unsigned> find_path_to_point_of_interest(const unsigned intersect_id_start, 
                                               const std::string point_of_interest_name,
                                               const double turn_penalty) {
    vector <unsigned> empty;
    return empty;
}